"""Module pour la gestion des alertes bas√©es sur les m√©triques de performance."""

import asyncio
import logging
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable, Union
from dataclasses import dataclass, field, asdict

from sadie.core.monitoring.metrics import CollectorMetricsManager, CollectorMetric

logger = logging.getLogger(__name__)

@dataclass
class PerformanceThreshold:
    """D√©finition d'un seuil d'alerte pour les m√©triques de performance."""
    
    metric_type: str  # Type de m√©trique (throughput, latency, error_rate, health)
    operator: str  # Op√©rateur (>, <, >=, <=, ==, !=)
    value: float  # Valeur seuil
    duration: int = 60  # Dur√©e en secondes pendant laquelle le seuil doit √™tre d√©pass√©
    cooldown: int = 300  # P√©riode de silence apr√®s le d√©clenchement (en secondes)
    enabled: bool = True  # Si le seuil est activ√©
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit le seuil en dictionnaire."""
        return asdict(self)
    
    def apply(self, metric_value: float) -> bool:
        """Applique l'op√©rateur pour v√©rifier si la valeur d√©passe le seuil."""
        if self.operator == '>':
            return metric_value > self.value
        elif self.operator == '<':
            return metric_value < self.value
        elif self.operator == '>=':
            return metric_value >= self.value
        elif self.operator == '<=':
            return metric_value <= self.value
        elif self.operator == '==':
            return metric_value == self.value
        elif self.operator == '!=':
            return metric_value != self.value
        else:
            logger.warning(f"Op√©rateur inconnu: {self.operator}")
            return False

@dataclass
class PerformanceAlert:
    """Alerte bas√©e sur les m√©triques de performance."""
    
    id: str  # Identifiant unique
    name: str  # Nom de l'alerte
    collector_name: Optional[str]  # Nom du collecteur (None = tous)
    exchange: Optional[str]  # Exchange (None = tous)
    symbols: List[str] = field(default_factory=list)  # Symboles concern√©s (vide = tous)
    thresholds: List[PerformanceThreshold] = field(default_factory=list)  # Seuils d'alerte
    notification_channels: List[str] = field(default_factory=list)  # Canaux de notification
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_triggered: Optional[datetime] = None
    trigger_count: int = 0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convertit l'alerte en dictionnaire."""
        data = asdict(self)
        data['created_at'] = self.created_at.isoformat()
        if self.last_triggered:
            data['last_triggered'] = self.last_triggered.isoformat()
        return data
    
    def is_applicable(self, metric: CollectorMetric) -> bool:
        """V√©rifie si cette alerte s'applique √† une m√©trique donn√©e."""
        # V√©rifie le collecteur
        if self.collector_name and self.collector_name != metric.name:
            return False
            
        # V√©rifie l'exchange
        if self.exchange and self.exchange != metric.exchange:
            return False
            
        # V√©rifie les symboles
        if self.symbols and not any(s in metric.symbols for s in self.symbols):
            return False
            
        # V√©rifie s'il y a un seuil pour ce type de m√©trique
        return any(t.metric_type == metric.metric_type and t.enabled for t in self.thresholds)
    
    def should_trigger(self, metric_value: float, metric_type: str) -> bool:
        """V√©rifie si l'alerte doit √™tre d√©clench√©e pour une valeur de m√©trique."""
        # V√©rifie chaque seuil applicable
        for threshold in self.thresholds:
            if threshold.metric_type == metric_type and threshold.enabled:
                if threshold.apply(metric_value):
                    # V√©rifie le cooldown
                    if (self.last_triggered and 
                        (datetime.utcnow() - self.last_triggered).total_seconds() < threshold.cooldown):
                        # En p√©riode de cooldown
                        return False
                    return True
        return False
    
    def trigger(self) -> Dict[str, Any]:
        """D√©clenche l'alerte et renvoie les donn√©es d'alerte."""
        self.last_triggered = datetime.utcnow()
        self.trigger_count += 1
        
        return {
            "alert_id": self.id,
            "alert_name": self.name,
            "triggered_at": self.last_triggered.isoformat(),
            "trigger_count": self.trigger_count,
            "notification_channels": self.notification_channels,
            "collector_name": self.collector_name,
            "exchange": self.exchange,
            "symbols": self.symbols
        }

class NotificationManager:
    """Gestionnaire des notifications pour les alertes."""
    
    def __init__(self):
        """Initialise le gestionnaire de notifications."""
        self.channels = {}
        self.setup_default_channels()
    
    def setup_default_channels(self):
        """Configure les canaux de notification par d√©faut."""
        self.register_channel("console", self._notify_console)
        self.register_channel("log", self._notify_log)
    
    def register_channel(self, channel_name: str, handler: Callable[[Dict[str, Any]], None]):
        """Enregistre un nouveau canal de notification."""
        self.channels[channel_name] = handler
        logger.info(f"Canal de notification enregistr√©: {channel_name}")
    
    async def send_notification(self, channel: str, alert_data: Dict[str, Any]):
        """Envoie une notification sur un canal sp√©cifique."""
        if channel in self.channels:
            try:
                await asyncio.to_thread(self.channels[channel], alert_data)
                logger.info(f"Notification envoy√©e sur le canal {channel}")
            except Exception as e:
                logger.error(f"Erreur lors de l'envoi de la notification sur {channel}: {str(e)}")
        else:
            logger.warning(f"Canal de notification inconnu: {channel}")
    
    def _notify_console(self, alert_data: Dict[str, Any]):
        """Notifie via la console (pour le d√©veloppement)."""
        print(f"\nüö® ALERTE DE PERFORMANCE üö®\n{json.dumps(alert_data, indent=2)}\n")
    
    def _notify_log(self, alert_data: Dict[str, Any]):
        """Notifie via les logs."""
        logger.warning(f"ALERTE DE PERFORMANCE: {json.dumps(alert_data)}")

class PerformanceAlertManager:
    """Gestionnaire des alertes de performance."""
    
    def __init__(self, metrics_manager: CollectorMetricsManager):
        """Initialise le gestionnaire d'alertes.
        
        Args:
            metrics_manager: Gestionnaire de m√©triques pour r√©cup√©rer les donn√©es
        """
        self.metrics_manager = metrics_manager
        self.alerts: Dict[str, PerformanceAlert] = {}
        self.notification_manager = NotificationManager()
        self.running = False
        self._task = None
        self.check_interval = 60  # Intervalle de v√©rification en secondes
        
        # Historique des alertes
        self.alert_history = []  # Liste des alertes d√©clench√©es
        self.max_history_size = 1000  # Taille maximale de l'historique
    
    async def start(self):
        """D√©marre le gestionnaire d'alertes."""
        if self.running:
            return
            
        self.running = True
        self._task = asyncio.create_task(self._check_alerts_loop())
        logger.info("Gestionnaire d'alertes d√©marr√©")
    
    async def stop(self):
        """Arr√™te le gestionnaire d'alertes."""
        if not self.running:
            return
            
        self.running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
            self._task = None
            
        logger.info("Gestionnaire d'alertes arr√™t√©")
    
    def add_alert(self, alert: PerformanceAlert) -> str:
        """Ajoute une nouvelle alerte.
        
        Returns:
            L'identifiant de l'alerte
        """
        self.alerts[alert.id] = alert
        logger.info(f"Alerte ajout√©e: {alert.name} (ID: {alert.id})")
        return alert.id
    
    def update_alert(self, alert_id: str, alert_data: Dict[str, Any]) -> bool:
        """Met √† jour une alerte existante.
        
        Returns:
            True si la mise √† jour a r√©ussi, False sinon
        """
        if alert_id not in self.alerts:
            logger.warning(f"Tentative de mise √† jour d'une alerte inexistante: {alert_id}")
            return False
            
        current_alert = self.alerts[alert_id]
        
        # Mise √† jour des champs
        for key, value in alert_data.items():
            if key == 'thresholds' and value:
                # Traitement sp√©cial pour les seuils
                current_alert.thresholds = [
                    PerformanceThreshold(**t) if isinstance(t, dict) else t
                    for t in value
                ]
            elif key == 'notification_channels':
                current_alert.notification_channels = value
            elif key == 'collector_name':
                current_alert.collector_name = value
            elif key == 'exchange':
                current_alert.exchange = value
            elif key == 'symbols':
                current_alert.symbols = value
            elif key == 'name':
                current_alert.name = value
                
        logger.info(f"Alerte mise √† jour: {current_alert.name} (ID: {alert_id})")
        return True
    
    def delete_alert(self, alert_id: str) -> bool:
        """Supprime une alerte.
        
        Returns:
            True si la suppression a r√©ussi, False sinon
        """
        if alert_id not in self.alerts:
            logger.warning(f"Tentative de suppression d'une alerte inexistante: {alert_id}")
            return False
            
        del self.alerts[alert_id]
        logger.info(f"Alerte supprim√©e: {alert_id}")
        return True
    
    def get_alert(self, alert_id: str) -> Optional[PerformanceAlert]:
        """R√©cup√®re une alerte par son identifiant."""
        return self.alerts.get(alert_id)
    
    def get_alerts(self) -> List[PerformanceAlert]:
        """R√©cup√®re toutes les alertes."""
        return list(self.alerts.values())
    
    def get_alert_history(self, limit: int = 100) -> List[Dict[str, Any]]:
        """R√©cup√®re l'historique des alertes d√©clench√©es."""
        return self.alert_history[-limit:] if limit > 0 else self.alert_history
    
    async def _check_alerts_loop(self):
        """Boucle de v√©rification des alertes."""
        while self.running:
            try:
                await self._check_alerts()
                await asyncio.sleep(self.check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Erreur lors de la v√©rification des alertes: {str(e)}")
                await asyncio.sleep(self.check_interval)
    
    async def _check_alerts(self):
        """V√©rifie toutes les alertes par rapport aux m√©triques r√©centes."""
        # R√©cup√®re les m√©triques r√©centes
        start_time = datetime.utcnow() - timedelta(minutes=5)
        metrics = await self.metrics_manager.get_metrics(start_time=start_time)
        
        if not metrics:
            return
            
        # Organise les m√©triques par type pour faciliter le traitement
        metrics_by_type = {}
        for metric in metrics:
            if metric.metric_type not in metrics_by_type:
                metrics_by_type[metric.metric_type] = []
            metrics_by_type[metric.metric_type].append(metric)
        
        # V√©rifie chaque alerte
        for alert_id, alert in self.alerts.items():
            # Pour chaque type de m√©trique de l'alerte
            for threshold in alert.thresholds:
                if not threshold.enabled:
                    continue
                    
                metric_type = threshold.metric_type
                if metric_type not in metrics_by_type:
                    continue
                    
                # V√©rifie chaque m√©trique de ce type
                for metric in metrics_by_type[metric_type]:
                    if alert.is_applicable(metric) and alert.should_trigger(metric.value, metric_type):
                        # D√©clenche l'alerte
                        alert_data = alert.trigger()
                        
                        # Ajoute le contexte de la m√©trique
                        alert_data["metric"] = {
                            "type": metric.metric_type,
                            "value": metric.value,
                            "unit": metric.unit,
                            "timestamp": metric.timestamp.isoformat()
                        }
                        
                        # Enregistre dans l'historique
                        self.alert_history.append(alert_data)
                        if len(self.alert_history) > self.max_history_size:
                            self.alert_history = self.alert_history[-self.max_history_size:]
                        
                        # Envoie les notifications
                        for channel in alert.notification_channels:
                            await self.notification_manager.send_notification(channel, alert_data)
                            
                        # Une alerte a √©t√© d√©clench√©e, passe √† l'alerte suivante
                        break

# Gestionnaire global des alertes (sera initialis√© avec le gestionnaire de m√©triques)
global_alert_manager = None

def initialize_alert_manager(metrics_manager: CollectorMetricsManager) -> PerformanceAlertManager:
    """Initialise le gestionnaire global des alertes."""
    global global_alert_manager
    if global_alert_manager is None:
        global_alert_manager = PerformanceAlertManager(metrics_manager)
    return global_alert_manager

async def start_alert_manager():
    """D√©marre le gestionnaire global des alertes."""
    if global_alert_manager:
        await global_alert_manager.start()

async def stop_alert_manager():
    """Arr√™te le gestionnaire global des alertes."""
    if global_alert_manager:
        await global_alert_manager.stop() 